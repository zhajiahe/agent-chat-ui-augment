---
globs: *.tsx,*.jsx
description: React component development guidelines and patterns
---

# React Component Development Guidelines

## Component Structure & Organization

### File Naming
- Use PascalCase for component files: `MessageList.tsx`, `ThreadView.tsx`
- Use kebab-case for non-component files: `use-stream.ts`, `api-client.ts`
- Keep component names descriptive and specific

### Component Patterns
Follow the established patterns in the codebase:

```tsx
// Functional component with TypeScript
interface MessageProps {
  content: string;
  author: string;
  timestamp: Date;
  className?: string;
}

export function Message({ content, author, timestamp, className }: MessageProps) {
  return (
    <div className={cn("message-container", className)}>
      <span className="author">{author}</span>
      <p className="content">{content}</p>
      <time className="timestamp">{timestamp.toISOString()}</time>
    </div>
  );
}
```

### Component Composition
- Break down large components into smaller, focused sub-components
- Use composition patterns for reusable UI elements
- Follow the [src/components/thread/](mdc:src/components/thread/) structure for complex features

## Hooks & State Management

### Custom Hooks
Follow patterns from [src/hooks/](mdc:src/hooks/):

```tsx
// Custom hook example
export function useFileUpload() {
  const [files, setFiles] = useState<File[]>([]);
  const [uploading, setUploading] = useState(false);
  
  const uploadFile = useCallback(async (file: File) => {
    setUploading(true);
    try {
      // upload logic
    } finally {
      setUploading(false);
    }
  }, []);
  
  return { files, uploading, uploadFile };
}
```

### Context Usage
Use the established context providers:
- [src/providers/Stream.tsx](mdc:src/providers/Stream.tsx) for streaming data
- [src/providers/Thread.tsx](mdc:src/providers/Thread.tsx) for thread management

```tsx
import { useStreamContext } from "@/providers/Stream";
import { useThreads } from "@/providers/Thread";

export function ChatComponent() {
  const { messages, isStreaming } = useStreamContext();
  const { threads, getThreads } = useThreads();
  
  // component logic
}
```

## Component Categories

### UI Components ([src/components/ui/](mdc:src/components/ui/))
Base components from shadcn/ui:
- Always use `cn()` utility for className merging
- Support `className` prop for extensibility
- Use `React.forwardRef` for DOM elements
- Follow the variant pattern with `cva` (class-variance-authority)

```tsx
import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        outline: "border border-input bg-background hover:bg-accent",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
```

### Thread Components ([src/components/thread/](mdc:src/components/thread/))
Chat-specific components:
- Follow streaming patterns for real-time updates
- Handle loading and error states gracefully
- Support both human and AI message types

```tsx
// Message component pattern
export function AIMessage({ message }: { message: AIMessage }) {
  const { isStreaming } = useStreamContext();
  
  return (
    <div className="ai-message">
      <MarkdownText content={getContentString(message)} />
      {isStreaming && <StreamingIndicator />}
      <ToolCalls calls={message.tool_calls} />
    </div>
  );
}
```

## Event Handling & Interactions

### Form Handling
Use controlled components with proper TypeScript:

```tsx
interface FormData {
  message: string;
  files: File[];
}

export function MessageInput() {
  const [formData, setFormData] = useState<FormData>({
    message: "",
    files: []
  });
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // handle submission
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <textarea
        value={formData.message}
        onChange={(e) => setFormData(prev => ({ 
          ...prev, 
          message: e.target.value 
        }))}
        placeholder="Type your message..."
      />
    </form>
  );
}
```

### Async Operations
Handle async operations properly:

```tsx
export function ThreadList() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const loadThreads = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const threads = await getThreads();
      setThreads(threads);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load threads");
    } finally {
      setLoading(false);
    }
  }, []);
  
  useEffect(() => {
    loadThreads();
  }, [loadThreads]);
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  
  return <div>{/* render threads */}</div>;
}
```

## Animation & Transitions

### Framer Motion Integration
Use Framer Motion for smooth animations:

```tsx
import { motion, AnimatePresence } from "framer-motion";

export function MessageList({ messages }: { messages: Message[] }) {
  return (
    <AnimatePresence mode="popLayout">
      {messages.map((message) => (
        <motion.div
          key={message.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={{ duration: 0.2 }}
        >
          <MessageComponent message={message} />
        </motion.div>
      ))}
    </AnimatePresence>
  );
}
```

## Performance Optimization

### Memoization
Use React.memo, useMemo, and useCallback appropriately:

```tsx
export const MessageComponent = React.memo(function MessageComponent({ 
  message 
}: { 
  message: Message 
}) {
  const processedContent = useMemo(
    () => processMarkdown(message.content),
    [message.content]
  );
  
  return <div>{processedContent}</div>;
});
```

### Key Props
Always provide stable keys for list items:

```tsx
// Good
{messages.map((message) => (
  <MessageComponent key={message.id} message={message} />
))}

// Avoid using array index
{messages.map((message, index) => (
  <MessageComponent key={index} message={message} />
))}
```