---
globs: *.ts,*.tsx
description: TypeScript coding standards and best practices
---

# TypeScript Coding Standards

## Type Safety & Definitions

### Strict TypeScript Configuration
Follow the strict TypeScript settings defined in [tsconfig.json](mdc:tsconfig.json):
- Enable `strict: true`
- Use `noEmit: true` for type checking only
- Target ES2017 for optimal compatibility

### Type Definitions
- Always define explicit types for function parameters and return values
- Use interfaces for object shapes, types for unions/intersections
- Prefer `type` for primitive unions: `type Status = "pending" | "completed"`
- Prefer `interface` for extensible object structures

```typescript
// Good
interface MessageProps {
  content: string;
  timestamp: Date;
  author: {
    id: string;
    name: string;
  };
}

function ProcessMessage(props: MessageProps): JSX.Element {
  // implementation
}

// Avoid
function ProcessMessage(props: any) {
  // implementation
}
```

### Import/Export Patterns
- Use named imports/exports for utilities and components
- Use default exports for pages and main components
- Import types with `type` keyword: `import type { Message } from "@langchain/langgraph-sdk"`

```typescript
// Good
import { cn } from "@/lib/utils";
import type { Message } from "@langchain/langgraph-sdk";
import { Button } from "@/components/ui/button";

// For main components
export default function ChatInterface() { }

// For utilities and sub-components
export function MessageProcessor() { }
export { MessageList } from "./message-list";
```

## Path Aliases
Use the configured path aliases from [tsconfig.json](mdc:tsconfig.json):
- `@/*` maps to `./src/*`
- Always use absolute imports with `@/` for internal modules
- Keep relative imports only for files in the same directory

```typescript
// Good
import { useStreamContext } from "@/providers/Stream";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

// Avoid deep relative imports
import { useStreamContext } from "../../../providers/Stream";
```

## LangGraph SDK Integration
When working with LangGraph types and utilities:

### Core Types
```typescript
import type { 
  Message, 
  AIMessage, 
  HumanMessage,
  Checkpoint 
} from "@langchain/langgraph-sdk";
import type { UIMessage } from "@langchain/langgraph-sdk/react-ui";
```

### Streaming Types
```typescript
// Follow patterns from src/providers/Stream.tsx
export type StateType = { 
  messages: Message[]; 
  ui?: UIMessage[] 
};

const useTypedStream = useStream<
  StateType,
  { MetaType: { artifact: [Component, Bag] } }
>();
```

## Error Handling
- Always handle async operations with try-catch or `.catch()`
- Use type-safe error handling patterns
- Log errors with `console.error()` for debugging

```typescript
// Good
try {
  const threads = await client.threads.search({ metadata });
  return threads;
} catch (error) {
  console.error("Failed to fetch threads:", error);
  return [];
}

// For promises
getThreads()
  .then(setThreads)
  .catch(console.error);
```

## React-Specific TypeScript

### Component Props
```typescript
interface ComponentProps {
  children: React.ReactNode;
  className?: string;
  variant?: "default" | "outline";
}

// For forwarded refs
const Button = React.forwardRef<
  HTMLButtonElement,
  ComponentProps
>(({ className, ...props }, ref) => {
  // implementation
});
```

### Hooks and Context
```typescript
// Context typing
interface StreamContextType {
  messages: Message[];
  isStreaming: boolean;
}

const StreamContext = createContext<StreamContextType | null>(null);

// Custom hook with null check
export function useStreamContext() {
  const context = useContext(StreamContext);
  if (!context) {
    throw new Error("useStreamContext must be used within StreamProvider");
  }
  return context;
}
```

## Utility Functions
- Use proper typing for utility functions in [src/lib/utils.ts](mdc:src/lib/utils.ts)
- Follow the `clsx` and `tailwind-merge` patterns for className utilities

```typescript
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```