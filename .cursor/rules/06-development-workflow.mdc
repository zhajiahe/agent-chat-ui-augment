---
alwaysApply: true
description: Development workflow and best practices
---

# Development Workflow & Best Practices

## Environment Setup

### Virtual Environment
**IMPORTANT**: Before running any commands in this project, activate the 'uv' virtual environment:

```bash
# Activate uv environment first
source .venv/bin/activate  # or equivalent uv activation command

# Then run project commands
pnpm dev
pnpm build
pnpm lint
```

### Package Management
Use **pnpm** as specified in [package.json](mdc:package.json):

```bash
# Install dependencies
pnpm install

# Development server
pnpm dev

# Build for production
pnpm build

# Linting and formatting
pnpm lint
pnpm lint:fix
pnpm format
pnpm format:check
```

## Code Quality

### Linting & Formatting
The project uses:
- **ESLint** with Next.js configuration
- **Prettier** with Tailwind CSS plugin
- **TypeScript** strict mode

```bash
# Check and fix linting issues
pnpm lint:fix

# Format code
pnpm format

# Check formatting
pnpm format:check
```

### Pre-commit Checklist
Before committing code:

1. ✅ Activate 'uv' virtual environment
2. ✅ Run `pnpm lint:fix` to fix linting issues
3. ✅ Run `pnpm format` to format code
4. ✅ Run `pnpm build` to ensure production build works
5. ✅ Test functionality in development mode
6. ✅ Check that all TypeScript errors are resolved

## File Organization

### Component Creation
When creating new components:

1. **Location**: Place in appropriate directory under [src/components/](mdc:src/components/)
   - UI components: `src/components/ui/`
   - Thread components: `src/components/thread/`
   - Feature components: `src/components/[feature-name]/`

2. **Naming**: Use PascalCase for component files
   - `MessageList.tsx`
   - `ThreadView.tsx`
   - `SettingsDialog.tsx`

3. **Structure**: Follow the established pattern
   ```tsx
   // ComponentName.tsx
   import { cn } from "@/lib/utils";
   
   interface ComponentProps {
     // props definition
   }
   
   export function ComponentName({ ...props }: ComponentProps) {
     // implementation
   }
   ```

### Hook Creation
Custom hooks go in [src/hooks/](mdc:src/hooks/):

```typescript
// use-feature-name.ts
import { useState, useCallback } from "react";

export function useFeatureName() {
  // hook implementation
  return { /* return values */ };
}
```

### Utility Functions
Utilities go in [src/lib/](mdc:src/lib/):

```typescript
// feature-utils.ts
export function utilityFunction(param: Type): ReturnType {
  // implementation
}
```

## Development Patterns

### State Management
1. **Local State**: Use `useState` and `useReducer` for component-level state
2. **Global State**: Use React Context providers in [src/providers/](mdc:src/providers/)
3. **Server State**: Use LangGraph SDK hooks for API data

### Error Handling
Always implement proper error handling:

```typescript
// Async operations
try {
  const result = await apiCall();
  setData(result);
} catch (error) {
  console.error("Operation failed:", error);
  setError(error instanceof Error ? error.message : "Unknown error");
}

// Promise chains
fetchData()
  .then(setData)
  .catch(console.error);
```

### Performance Considerations
1. **Memoization**: Use `React.memo`, `useMemo`, `useCallback` appropriately
2. **Code Splitting**: Use dynamic imports for large components
3. **Image Optimization**: Use Next.js `Image` component
4. **Bundle Analysis**: Run `pnpm build` to check bundle size

## Testing Strategy

### Component Testing
- Test component rendering with different props
- Test user interactions and event handlers
- Test error states and edge cases

### Integration Testing
- Test provider context integration
- Test API integration with mock data
- Test streaming functionality

### Accessibility Testing
- Test keyboard navigation
- Test screen reader compatibility
- Test color contrast and visual accessibility

## Deployment Considerations

### Environment Variables
Set up proper environment variables for different environments:

```bash
# Development (.env.local)
NEXT_PUBLIC_ASSISTANT_ID="agent"
LANGGRAPH_API_URL="http://localhost:2024"  # Local development
LANGSMITH_API_KEY="lsv2_dev_key"

# Production
NEXT_PUBLIC_ASSISTANT_ID="prod-agent"
LANGGRAPH_API_URL="https://prod-langgraph-server.com"
LANGSMITH_API_KEY="lsv2_prod_key"
```

### Build Optimization
- Ensure production build passes: `pnpm build`
- Check for unused dependencies
- Optimize images and assets
- Test with production environment variables

## Debugging

### Common Issues
1. **LangGraph Connection**: Check API URL and key in environment variables
2. **Streaming Issues**: Verify WebSocket connections and event handlers
3. **Styling Issues**: Check Tailwind class conflicts and CSS variable usage
4. **TypeScript Errors**: Ensure all types are properly defined and imported

### Debug Tools
```typescript
// Stream debugging
console.log("Stream state:", streamValue);
console.log("Current messages:", messages);

// Component debugging
useEffect(() => {
  console.log("Component rendered with props:", props);
}, [props]);
```

## Documentation

### Code Comments
- Add JSDoc comments for complex functions
- Explain business logic and non-obvious code
- Document component props and return types

```typescript
/**
 * Processes incoming LangGraph messages and formats them for display
 * @param messages - Array of raw LangGraph messages
 * @param options - Processing options
 * @returns Formatted messages ready for UI rendering
 */
export function processMessages(
  messages: Message[],
  options: ProcessingOptions
): FormattedMessage[] {
  // implementation
}
```

### README Updates
When adding new features:
- Update feature documentation
- Add setup instructions if needed
- Document environment variable changes
- Include usage examples

## Security Considerations

### API Security
- Never expose `LANGGRAPH_API_URL` or `LANGSMITH_API_KEY` to the client
- Always use the internal API proxy at `/api/*`
- Validate and sanitize user inputs
- Implement proper error handling without exposing sensitive information

### Client-Side Security
- Sanitize user-generated content
- Validate file uploads
- Implement proper CORS settings
- Use HTTPS in production

## Contribution Guidelines

### Code Style
- Follow existing code patterns and conventions
- Use TypeScript strict mode
- Follow the established component and file naming conventions
- Keep functions small and focused

### Git Workflow
1. Create feature branches from main
2. Make small, focused commits with clear messages
3. Test thoroughly before creating pull requests
4. Include documentation updates when needed

### Review Checklist
- ✅ Code follows project conventions
- ✅ All tests pass
- ✅ No linting or TypeScript errors
- ✅ Documentation is updated
- ✅ Performance impact is considered
- ✅ Accessibility guidelines are followed